"""Prepare the dictionary of operation nodes and variables for pruning.
*** In tensorflow 1.x, the operation(OP) in node is include the info of node_def, OP type, 
*** and inputs of node, that will help us to find the variables name.

Generate Strip_Nodes_Dict.pkl and Strip_Vars_Dict.pkl.
The key and value in these dictionaies are used to modify the checkpoint.
We use the checkpoint to define new graph for exporting inference pb file.

Read the key and value in Scope_Conv_Dict.pkl to find the nodes of convolution,
bias, and batch-normalization and their variable names.

Using the new checkpoint that is generated by rebuild_ckpt_export and without training node.

Examples:
    scope_name = ['MobilenetV2/expanded_conv_1']
    strip_nodes_dict = {
        'MobilenetV2/expanded_conv_1/expand/Conv2D': [
            [
            'MobilenetV2/expanded_conv_1/expand/BatchNorm/gamma:0', 
            'MobilenetV2/expanded_conv_1/expand/BatchNorm/beta:0'
            ], 
            0
        ]
        'MobilenetV2/expanded_conv_1/depthwise/depthwise': [
            [
            'MobilenetV2/expanded_conv_1/depthwise/BatchNorm/gamma:0',
            'MobilenetV2/expanded_conv_1/depthwise/BatchNorm/beta:0'
            ], 
            0
        ]
        'MobilenetV2/expanded_conv_1/project/Conv2D': [
            [
            'MobilenetV2/expanded_conv_1/project/BatchNorm/gamma:0', 
            'MobilenetV2/expanded_conv_1/project/BatchNorm/beta:0'
            ], 
            None
        ]
    }

    strip_vars_dict = {
        'MobilenetV2/expanded_conv_1/': [
            ['MobilenetV2/expanded_conv_1/expand/weights:0', 3], 
            ['MobilenetV2/expanded_conv_1/expand/BatchNorm/gamma:0', 0], 
            ['MobilenetV2/expanded_conv_1/expand/BatchNorm/beta:0', 0], 
            ['MobilenetV2/expanded_conv_1/expand/BatchNorm/moving_mean:0', 0], 
            ['MobilenetV2/expanded_conv_1/expand/BatchNorm/moving_variance:0', 0], 
            ['MobilenetV2/expanded_conv_1/depthwise/depthwise_weights:0', 2], 
            ['MobilenetV2/expanded_conv_1/depthwise/BatchNorm/gamma:0', 0], 
            ['MobilenetV2/expanded_conv_1/depthwise/BatchNorm/beta:0', 0], 
            ['MobilenetV2/expanded_conv_1/depthwise/BatchNorm/moving_mean:0', 0], 
            ['MobilenetV2/expanded_conv_1/depthwise/BatchNorm/moving_variance:0', 0], 
            ['MobilenetV2/expanded_conv_1/project/weights:0', 2]
        ]
    }

The above variable names could be search in pbtxt.

"""
import numpy as np
import argparse
import pickle
import os
import tensorflow as tf
from tensorflow.contrib import graph_editor as ge


def strip_get_params(input_ckpt, input_meta, scope_conv_path, output_dir):
    """Generate relevant variable dictionary for pruning.
    Args:
        input_ckpt: Tensorflow 1.x checkpoint file.
        input_meta: Tensorflow 1.x model structure file.
        scope_conv_path: The path of Scope_Conv_Dict.pkl for searching variable name.
        output_dir: Diretory that save variable dictionaries as .pkl.
    Outputs:
        Strip_Nodes_Dict.pkl and Strip_Vars_Dict.pkl
        will be saved in output_dir.
    """
    strip_nodes_dict_path = os.path.join(output_dir, 'Strip_Nodes_Dict.pkl')
    strip_vars_dict_path = os.path.join(output_dir, 'Strip_Vars_Dict.pkl')

    graph = tf.Graph()
    with tf.Session(graph=graph) as sess:

        # Load the graph and weights ====
        saver = tf.train.import_meta_graph(input_meta)
        saver.restore(sess, input_ckpt)

        list_of_ops = ge.make_list_of_op(graph)
        # Make the OP list of bias and BN
        # to find the bias and BN variable
        list_of_bias = [x for x in list_of_ops if x.type == 'BiasAdd' or x.type == 'FusedBatchNorm' or x.type == 'FusedBatchNormV2' or x.type == 'FusedBatchNormV3']

        with open(scope_conv_path, 'rb') as f:
            scope_conv_dict = pickle.load(f)

        # Get node and variable names via scope.
        strip_nodes_dict = {}
        strip_vars_dict = {}
        for scope, conv_sets in scope_conv_dict.items():
            node_name_dim = []
            var_name_dim = []
            # For convolution OP
            for conv_name, conv_dim in conv_sets:
                conv_op = graph.get_operation_by_name(conv_name)
                # Find the convolution variable name by convolution OP.
                conv_var = [x.replace('/read', ':0') for x in conv_op.node_def.input if '/read' in x]
                var_name_dim.append([conv_var[0], conv_dim])

                # Find the variable name that is assign OP shape.
                conv_assign = [x.replace('/read', '/Assign') for x in conv_op.node_def.input if '/read' in x]
                assign_name = conv_assign[0]
                assign_op = graph.get_operation_by_name(assign_name)
                for i_name in assign_op.node_def.input:
                    op = graph.get_operation_by_name(i_name)
                    conv_var_name = i_name + '/shape' if op.type == 'Add' else i_name
                    node_name_dim.append([conv_var_name, conv_dim])

                # For bias and BN OP
                if conv_op.type == 'Conv2D' and conv_dim == 2:
                    # When the OP is convolution and pruning dimension is in W (dimension is [N, H, W, C])
                    # the pruning isn't be effected by bias or BN. 
                    continue
                for bias_op in list_of_bias:
                    if conv_name in bias_op.node_def.input:
                        b_assign = [x.replace('/read', '/Assign') for x in bias_op.node_def.input if '/read' in x]
                        for name in b_assign:
                            assign_op = graph.get_operation_by_name(name)
                            for b_i_name in assign_op.node_def.input:
                                node_name_dim.append([b_i_name, 0])

                        b_vars = [x.replace('/read', ':0') for x in bias_op.node_def.input if '/read' in x]
                        pruned_b_dim = 0
                        for b_var in b_vars:
                            var_name_dim.append([b_var, pruned_b_dim])
                            pass

            strip_nodes_dict[scope] = node_name_dim
            strip_vars_dict[scope] = var_name_dim


        with open(strip_nodes_dict_path,"wb") as f:
            pickle.dump(strip_nodes_dict,f)
            print('{} Strip Nodes Dict Dumped. {}'.format('='*15, '='*15))
        with open(strip_vars_dict_path,"wb") as f:
            pickle.dump(strip_vars_dict,f)
            print('{} Strip Vars Dict Dumped. {}'.format('='*15, '='*15))
        pass



if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('--input_ckpt', type=str, required=True,
                        default=None, help='CKPT path.')
    parser.add_argument('--input_meta', type=str, 
                        default=None, help='meta path.')
    parser.add_argument('--scope_conv', type=str, required=True,
                        default=None, help='Scope_Conv_Dict.pkl path.')
    parser.add_argument('-o', '--output_dir', type=str, required=True,
                        default='Pruning_Vars', help='Output path.')

    args = parser.parse_args()

    if args.input_meta is None:
        args.input_meta = args.input_ckpt + '.meta'
        pass

    if not os.path.exists(args.output_dir):
        os.mkdir(args.output_dir)
        pass

    strip_get_params(args.input_ckpt, args.input_meta, args.scope_conv, args.output_dir)
